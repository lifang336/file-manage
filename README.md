# Electron 智能文件管理器

## 简介

Electron 智能文件管理器是一款全新的桌面应用程序，旨在利用先进的智能技术，帮助用户高效地整理和管理本地文件。本应用基于 Electron 构建，提供了强大的文件分类、移动和配置功能，支持命令行和图形用户界面操作，致力于为用户带来清爽、有序的文件管理体验。

## 核心功能

本文件管理器具备以下核心功能，旨在提供灵活且强大的文件整理能力：

### 1. 文件选择与指定目录

- **源文件目录选择**：用户可以轻松选择需要进行整理的源文件所在的目录。
- **输出目录指定**：用户可以指定整理后文件的输出目录。如果未指定，整理操作将在源目录内直接进行，文件会被移动到源目录下的相应分类子文件夹中。

### 2. 核心文件分类与整理逻辑

本应用的核心在于其智能化的文件分类与整理机制：

- **基于文件名语义的分类**：利用先进的大语言模型 (LLM) 对文件名进行语义分析，实现超越传统规则的智能分类。
- **双模式分类**：
  - **模式 A (手动分类)**：用户可以预先定义一组分类文件夹的名称列表。应用将根据这些名称，将文件名与之匹配的文件归入相应的文件夹。
  - **模式 B (LLM 自动分类)**：
    - **阶段一 (全局分类发现)**：
      - LLM 分析用户提供的文件名样本，自动学习并生成全局性的分类建议。
      - 用户可以提供“分类焦点/说明”来引导 LLM 的分类方向，使其更符合个人需求。
      - 用户可以指定期望 LLM 生成的“分类数量”，以控制分类的粒度。
      - 可配置用于全局分类发现的“最大文件名样本数量”，以平衡效率和准确性。
    - **阶段二 (单个文件归类)**：在全局分类确定后，LLM 会将每个待整理的文件智能地分配到最合适的分类中。
- **文件移动**：根据最终的分类结果，应用会自动将文件移动到对应的分类子文件夹内。
- **文件夹创建**：如果在整理过程中发现目标分类子文件夹尚不存在，应用会自动创建这些文件夹。
- **未分类文件处理**：对于无法匹配任何分类规则或 LLM 无法明确分类的文件，它们将被统一移动到用户指定的“未分类”文件夹中。
  - 用户可以自定义“未分类”文件夹的名称，默认为“未分类”。

### 3. 操作范围与执行方式

- **递归处理**：用户可以选择是否递归处理源目录下的所有子文件夹及其包含的文件，实现对整个目录树的全面整理。
- **模拟运行 (Dry Run)**：在实际执行任何文件系统更改之前，用户可以启用模拟运行模式。此模式会详细列出计划执行的操作（例如，哪些文件将被移动到哪个文件夹，哪些新文件夹将被创建），帮助用户预览整理效果并避免误操作。

### 4. 配置与辅助功能

- **API 密钥管理**：为了使用基于 LLM 的智能分类功能，用户需要提供相应的 API 密钥。本应用支持多种密钥配置方式：
  - 通过命令行参数传入。
  - 通过系统环境变量设置。
  - 通过图形用户界面 (GUI) 直接输入。
- **日志记录**：
  - **操作过程日志**：在 GUI 中实时显示详细的操作步骤、当前状态信息以及在整理过程中可能出现的任何错误或警告，方便用户追踪进度和排查问题。
  - **原始目录结构日志**：在执行实际的文件整理操作之前，应用会自动将源目录的原始文件结构（包括文件和文件夹列表）保存为一个 Markdown 文件。此功能旨在提供一个备份，方便用户在需要时追溯文件的原始位置。该功能默认启用，但用户可以选择禁用。
- **文件名冲突处理**：当目标分类文件夹中已存在与待移动文件同名的文件时，系统会自动为新移动的文件名添加数字后缀（如 \`file_1.txt\`, \`file_2.txt\`），以避免覆盖现有文件，确保数据安全。
- **系统文件忽略**：应用会自动识别并跳过处理常见的操作系统隐藏文件或系统文件（例如 macOS 的 \`.DS_Store\` 文件、Windows 的 \`Thumbs.db\` 等），避免对系统文件进行不必要的操作。
- **输出目录保护**：在启用递归处理时，如果输出目录被设置在源目录的子目录中，应用会自动跳过对输出目录本身的处理，以防止意外的文件操作或可能导致的无限循环。

### 5. 用户交互界面

为了满足不同用户的使用习惯，本应用提供了两种交互方式：

- **命令行界面 (CLI)**：提供一套完整的命令行参数，允许高级用户或开发者通过脚本自动化执行所有文件整理功能，并进行精细化配置。
- **图形用户界面 (GUI)**：基于 Electron 构建，提供一个直观易用的图形界面。用户可以通过简单的点选、拖拽和输入操作来完成文件整理任务，降低了使用门槛。

## 技术栈

- **核心框架**: Electron
- **智能分类**: 大语言模型 (LLM) API (具体模型可配置)

## 如何开始

### 开发环境

1. 克隆本仓库

   ```bash
   git clone <repository-url>
   cd file-manage
   ```

2. 安装依赖

   ```bash
   pnpm install
   ```

3. 开发模式运行
   ```bash
   pnpm run electron:dev
   ```

### 构建和打包

详细的构建和打包说明请参考 [BUILD.md](BUILD.md)。

#### 快速打包

```bash
# 打包 macOS 版本
./scripts/build.sh mac

# 打包 Windows 版本 (在 Windows 系统上)
scripts\build.bat win

# 打包所有平台版本
./scripts/build.sh all
```

#### 可用的构建命令

- `pnpm run build` - 构建应用程序
- `pnpm run dist:mac` - 打包 macOS 版本
- `pnpm run dist:win` - 打包 Windows 版本
- `pnpm run dist:all` - 打包所有平台版本
- `pnpm run pack` - 仅打包不压缩（用于测试）

## 构建与依赖注意事项

### 关于 `pnpm.onlyBuiltDependencies`

在项目的 [`package.json`](package.json) 文件中，你可能会注意到以下配置：

\`\`\`json
{
"pnpm": {
"onlyBuiltDependencies": [
"electron"
]
}
}
\`\`\`

**作用解释：**

`pnpm.onlyBuiltDependencies` 字段用于告诉 pnpm，在执行 `pnpm install` 时，哪些依赖项（及其传递依赖）的生命周期脚本（例如 `postinstall` 脚本，常用于编译原生模块）**必须**被执行。

默认情况下，为了提升安装速度和安全性，pnpm 可能会跳过某些可选的或它认为不需要的构建脚本。然而，对于像 Electron 这样的依赖，它可能包含或依赖于一些需要在特定平台（如你的 macOS）或特定 Node.js/Electron 版本下编译的原生模块。

**为什么需要它？**

如果这些原生模块没有被正确编译，可能会导致应用在启动或运行时出现错误，例如“找不到模块”、“动态链接库（.dylib 或 .node 文件）加载失败”等问题。

将 `"electron"` 添加到 `onlyBuiltDependencies` 数组中，可以确保 pnpm 在安装过程中会执行 `electron` 包及其相关依赖（如果它们也有构建脚本）的构建步骤。这有助于保证 Electron 及其底层依赖能够正确适配你的操作系统（macOS）和项目环境，从而避免潜在的运行时错误。

简而言之，这个配置增强了项目在不同环境下的构建可靠性和稳定性，特别是对于依赖原生代码的复杂包如 Electron。

## 贡献

欢迎对本项目做出贡献！请阅读 \`CONTRIBUTING.md\` (如果创建) 了解更多细节。

## 许可证

本项目采用 [MIT](LICENSE) (如果创建) 许可证。
